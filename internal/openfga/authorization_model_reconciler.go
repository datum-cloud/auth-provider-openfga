package openfga

import (
	"context"
	"encoding/hex"
	"fmt"
	"hash/fnv"
	"sort"
	"strings"

	"github.com/google/go-cmp/cmp"
	openfgav1 "github.com/openfga/api/proto/openfga/v1"
	iamdatumapiscomv1alpha1 "go.miloapis.com/milo/pkg/apis/iam/v1alpha1"
	"google.golang.org/protobuf/testing/protocmp"
	"google.golang.org/protobuf/types/known/wrapperspb"
	logf "sigs.k8s.io/controller-runtime/pkg/log"
)

type AuthorizationModelReconciler struct {
	StoreID string
	OpenFGA openfgav1.OpenFGAServiceClient
}

// getAuthorizationModelComparisonOptions returns the standardized cmp.Option slice for comparing authorization models
// with options to ignore ordering differences and the OpenFGA-assigned id field
func getAuthorizationModelComparisonOptions() []cmp.Option {
	return []cmp.Option{
		// Use protocmp.Transform for proper protobuf message comparison
		protocmp.Transform(),
		// Ignore the id field since it's assigned by OpenFGA and not semantically meaningful
		protocmp.IgnoreFields(&openfgav1.AuthorizationModel{}, "id"),
		// Sort repeated fields that can have different orderings without changing semantics
		protocmp.SortRepeated(func(a, b *openfgav1.TypeDefinition) bool {
			return a.Type < b.Type
		}),
		protocmp.SortRepeated(func(a, b *openfgav1.RelationReference) bool {
			return a.Type < b.Type
		}),
	}
}

// authorizationModelsEqual compares two authorization models using go-cmp with protocmp
// and options to ignore ordering differences that don't affect semantics
func authorizationModelsEqual(current, merged *openfgav1.AuthorizationModel) bool {
	if current == nil && merged == nil {
		return true
	}
	if current == nil || merged == nil {
		return false
	}

	return cmp.Equal(current, merged, getAuthorizationModelComparisonOptions()...)
}

func (r *AuthorizationModelReconciler) ReconcileAuthorizationModel(ctx context.Context, protectedResources []iamdatumapiscomv1alpha1.ProtectedResource) error {
	log := logf.FromContext(ctx).WithValues("component", "AuthorizationModelReconciler")

	currentAuthorizationModel, err := r.getCurrentAuthorizationModel(ctx)
	if err != nil {
		return fmt.Errorf("failed to get current authorization model: %w", err)
	}

	newAuthorizationModel, err := r.createExpectedAuthorizationModel(protectedResources)
	if err != nil {
		return fmt.Errorf("failed to create new authorization model: %w", err)
	}

	mergedAuthorizationModel := &openfgav1.AuthorizationModel{
		SchemaVersion: newAuthorizationModel.SchemaVersion,
		// Conditions are not dynamically generated by the IAM system so we can
		// safely set the conditions to whatever is already in the authorization
		// model.
		//
		// TODO: Update when conditions are dynamically created by the IAM system.
		Conditions: currentAuthorizationModel.Conditions,
	}

	// Create a map to track existing types and prevent duplicates
	existingTypes := make(map[string]bool)

	// IAM system managed types - these will be replaced with new definitions
	iamSystemTypes := map[string]bool{
		"iam.miloapis.com/InternalUser":      true,
		"iam.miloapis.com/InternalUserGroup": true,
		"iam.miloapis.com/Role":              true,
		"iam.miloapis.com/RoleBinding":       true,
		"iam.miloapis.com/Root":              true,
	}

	// Go through the existing type definitions and add any that were provided
	// through the OpenFGA schema language, excluding IAM system managed types.
	for _, typeDefinition := range currentAuthorizationModel.TypeDefinitions {
		// Skip IAM system managed types as they will be regenerated
		if iamSystemTypes[typeDefinition.Type] {
			continue
		}

		// The type definitions added by the IAM system will always be in the
		// format `{service_name}/{resource_type}`. Since this format is only
		// valid when building the resource model in JSON, we can safely
		// guarantee that type definitions added by Datum OS through the OpenFGA
		// schema language will never contain a "/" character.
		if len(strings.Split(typeDefinition.Type, "/")) == 1 {
			mergedAuthorizationModel.TypeDefinitions = append(mergedAuthorizationModel.TypeDefinitions, typeDefinition)
			existingTypes[typeDefinition.Type] = true
		}
	}

	// Add new type definitions, but only if they don't already exist
	for _, typeDefinition := range newAuthorizationModel.TypeDefinitions {
		if !existingTypes[typeDefinition.Type] {
			mergedAuthorizationModel.TypeDefinitions = append(mergedAuthorizationModel.TypeDefinitions, typeDefinition)
			existingTypes[typeDefinition.Type] = true
		}
	}

	// Compare using go-cmp with protocmp for proper protobuf comparison
	if authorizationModelsEqual(currentAuthorizationModel, mergedAuthorizationModel) {
		log.Info("Authorization model is already up to date, skipping write operation")
		return nil
	}

	log.Info("Authorization model has changed, updating OpenFGA store",
		"currentTypeCount", len(currentAuthorizationModel.TypeDefinitions),
		"mergedTypeCount", len(mergedAuthorizationModel.TypeDefinitions))

	// Add debugging diff output to understand what's different
	if diff := cmp.Diff(currentAuthorizationModel, mergedAuthorizationModel, getAuthorizationModelComparisonOptions()...); diff != "" {
		log.Info("Authorization model diff detected", "diff", diff)
	}

	_, err = r.OpenFGA.WriteAuthorizationModel(ctx, &openfgav1.WriteAuthorizationModelRequest{
		StoreId:         r.StoreID,
		SchemaVersion:   mergedAuthorizationModel.SchemaVersion,
		TypeDefinitions: mergedAuthorizationModel.TypeDefinitions,
		Conditions:      mergedAuthorizationModel.Conditions,
	})
	if err != nil {
		return fmt.Errorf("failed to reconcile authorization model: %w", err)
	}

	return nil
}

func (r *AuthorizationModelReconciler) getCurrentAuthorizationModel(ctx context.Context) (*openfgav1.AuthorizationModel, error) {
	models, err := r.OpenFGA.ReadAuthorizationModels(ctx, &openfgav1.ReadAuthorizationModelsRequest{
		StoreId: r.StoreID,
		// Only request the first result because it'll always be the latest
		// authorization model that was created for the store.
		PageSize: wrapperspb.Int32(1),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to list authorization models: %w", err)
	}

	if len(models.AuthorizationModels) == 0 {
		// No authorization model has been created yet so we'll just return an
		// empty model.
		return &openfgav1.AuthorizationModel{}, nil
	}

	// Retrieve the full authorization model definition
	resp, err := r.OpenFGA.ReadAuthorizationModel(ctx, &openfgav1.ReadAuthorizationModelRequest{
		StoreId: r.StoreID,
		Id:      models.AuthorizationModels[0].Id,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get authorization model: %w", err)
	}

	return resp.AuthorizationModel, nil
}

func (r *AuthorizationModelReconciler) createExpectedAuthorizationModel(protectedResources []iamdatumapiscomv1alpha1.ProtectedResource) (*openfgav1.AuthorizationModel, error) {
	// If no ProtectedResources exist, return a minimal authorization model
	if len(protectedResources) == 0 {
		return getMinimalAuthorizationModel(), nil
	}

	// Build the resource hierarchy
	resourceGraph, err := getResourceGraph(protectedResources)
	if err != nil {
		return nil, fmt.Errorf("failed to get resource graph: %v", err)
	}

	// Calculate hierarchical permissions for each resource type
	hierarchicalPermissions := calculateHierarchicalPermissions(resourceGraph)

	// Get all permissions for IAM types (roles, role bindings, root)
	allPermissions := getAllPermissions(protectedResources)

	// Collect all resource types from the resource graph
	resourceTypes := getAllResourceTypes(resourceGraph)

	// Create base IAM type definitions in deterministic order
	typeDefinitions := []*openfgav1.TypeDefinition{
		getUserTypeDefinition(),
		getUserGroupTypeDefinition(),
		getRoleTypeDefinition(allPermissions),
		getRoleBindingTypeDefinition(allPermissions),
	}

	// Only add Root type if we have resources
	if len(resourceTypes) > 0 {
		typeDefinitions = append(typeDefinitions, getRootTypeDefinition(allPermissions, resourceTypes))
	}

	// Get resource type definitions and add them in sorted order
	resourceTypeDefinitions := getResourceTypeDefinitionsWithHierarchicalPermissions(hierarchicalPermissions, resourceGraph)

	// Sort resource type definition keys for deterministic ordering
	var sortedResourceTypes []string
	for resourceType := range resourceTypeDefinitions {
		sortedResourceTypes = append(sortedResourceTypes, resourceType)
	}
	sort.Strings(sortedResourceTypes)

	// Add resource type definitions in sorted order
	for _, resourceType := range sortedResourceTypes {
		typeDefinitions = append(typeDefinitions, resourceTypeDefinitions[resourceType])
	}

	return &openfgav1.AuthorizationModel{
		SchemaVersion:   "1.2",
		TypeDefinitions: typeDefinitions,
	}, nil
}

func getResourceParentRelatedTypes(parents []string) (relations []*openfgav1.RelationReference) {
	for _, parent := range parents {
		relations = append(relations, &openfgav1.RelationReference{
			Type: parent,
		})
	}
	return
}

func getResourceTypeDefinition(permissions []string, resourceNode *resourceGraphNode) *openfgav1.TypeDefinition {
	typeDefinition := &openfgav1.TypeDefinition{
		Type: resourceNode.ResourceType,
		Metadata: &openfgav1.Metadata{
			Relations: map[string]*openfgav1.RelationMetadata{
				// All resources can have a role binding associated with it to
				// grant a subject access directly to the Resource. Permissions
				// bound to the resource will be inherited by any child
				// resources.
				"iam.miloapis.com/RoleBinding": {
					DirectlyRelatedUserTypes: []*openfgav1.RelationReference{
						{
							Type: "iam.miloapis.com/RoleBinding",
						},
					},
				},
				// RootBinding relation allows specific resource instances to be linked
				// to their corresponding root objects for ResourceKind policy bindings
				"iam.miloapis.com/RootBinding": {
					DirectlyRelatedUserTypes: []*openfgav1.RelationReference{
						{
							Type: "iam.miloapis.com/Root",
						},
					},
				},
			},
			SourceInfo: &openfgav1.SourceInfo{
				File: "dynamically_managed_iam_datumapis_com.fga",
			},
			Module: strings.Split(resourceNode.ResourceType, "/")[0],
		},
		Relations: map[string]*openfgav1.Userset{
			"iam.miloapis.com/RoleBinding": {
				Userset: &openfgav1.Userset_This{},
			},
			"iam.miloapis.com/RootBinding": {
				Userset: &openfgav1.Userset_This{},
			},
		},
	}

	// Only create a parent reference if the resource has parent relationships and
	// we're not working on the root resource.
	if len(resourceNode.ParentResources) > 0 {
		typeDefinition.Metadata.Relations["parent"] = &openfgav1.RelationMetadata{
			DirectlyRelatedUserTypes: getResourceParentRelatedTypes(resourceNode.ParentResources),
		}
		typeDefinition.Relations["parent"] = &openfgav1.Userset{
			Userset: &openfgav1.Userset_This{},
		}
	}

	for _, permission := range permissions {
		hashedPermission := hashPermission(permission)

		typeDefinition.Relations[hashedPermission] = &openfgav1.Userset{
			Userset: &openfgav1.Userset_Union{
				Union: &openfgav1.Usersets{
					Child: []*openfgav1.Userset{
						// Direct role binding to this specific resource
						{
							Userset: &openfgav1.Userset_TupleToUserset{
								TupleToUserset: &openfgav1.TupleToUserset{
									Tupleset: &openfgav1.ObjectRelation{
										Relation: "iam.miloapis.com/RoleBinding",
									},
									ComputedUserset: &openfgav1.ObjectRelation{
										Relation: hashedPermission,
									},
								},
							},
						},
						// Inherit permission from root binding (ResourceKind policy bindings)
						{
							Userset: &openfgav1.Userset_TupleToUserset{
								TupleToUserset: &openfgav1.TupleToUserset{
									Tupleset: &openfgav1.ObjectRelation{
										Relation: "iam.miloapis.com/RootBinding",
									},
									ComputedUserset: &openfgav1.ObjectRelation{
										Relation: hashedPermission,
									},
								},
							},
						},
					},
				},
			},
		}

		if len(resourceNode.ParentResources) > 0 {
			typeDefinition.Relations[hashedPermission].GetUnion().Child = append(typeDefinition.Relations[hashedPermission].GetUnion().Child,
				&openfgav1.Userset{
					Userset: &openfgav1.Userset_TupleToUserset{
						TupleToUserset: &openfgav1.TupleToUserset{
							Tupleset: &openfgav1.ObjectRelation{
								Relation: "parent",
							},
							ComputedUserset: &openfgav1.ObjectRelation{
								Relation: hashedPermission,
							},
						},
					},
				},
			)
		}
	}

	return typeDefinition
}

func getAllPermissions(protectedResources []iamdatumapiscomv1alpha1.ProtectedResource) []string {
	var permissions []string
	for _, pr := range protectedResources {
		if pr.Spec.ServiceRef.Name == "" {
			fmt.Printf("Warning: ProtectedResource %s has empty ServiceRef.Name, skipping its permissions\n", pr.Name)
			continue
		}
		for _, permission := range pr.Spec.Permissions {
			if pr.Spec.Plural == "" {
				fmt.Printf("Warning: ProtectedResource %s (service %s) has an empty Plural name, skipping permission '%s'\n", pr.Name, pr.Spec.ServiceRef.Name, permission)
				continue
			}
			permissions = append(permissions, fmt.Sprintf("%s/%s.%s", pr.Spec.ServiceRef.Name, pr.Spec.Plural, permission))
		}
	}

	// Sort permissions for deterministic ordering
	sort.Strings(permissions)
	return permissions
}

func getAllResourceTypes(node *resourceGraphNode) []string {
	if node == nil {
		return []string{}
	}

	var resourceTypes []string

	// Add current node's resource type if it's not the root
	if node.ResourceType != "iam.miloapis.com/Root" {
		resourceTypes = append(resourceTypes, node.ResourceType)
	}

	// Recursively collect resource types from child nodes
	for _, child := range node.ChildResources {
		resourceTypes = append(resourceTypes, getAllResourceTypes(child)...)
	}

	// Sort for deterministic ordering and remove duplicates
	sort.Strings(resourceTypes)
	return removeDuplicateStrings(resourceTypes)
}

// removeDuplicateStrings removes duplicate strings from a sorted slice
func removeDuplicateStrings(sorted []string) []string {
	if len(sorted) == 0 {
		return sorted
	}

	result := []string{sorted[0]}
	for i := 1; i < len(sorted); i++ {
		if sorted[i] != sorted[i-1] {
			result = append(result, sorted[i])
		}
	}
	return result
}

func getMinimalAuthorizationModel() *openfgav1.AuthorizationModel {
	// Return a minimal authorization model with just the basic IAM types
	// and no permissions when no ProtectedResources exist
	return &openfgav1.AuthorizationModel{
		SchemaVersion: "1.2",
		TypeDefinitions: []*openfgav1.TypeDefinition{
			getUserTypeDefinition(),
			getUserGroupTypeDefinition(),
			getRoleTypeDefinition([]string{}),        // Empty permissions
			getRoleBindingTypeDefinition([]string{}), // Empty permissions
			// Skip Root type entirely when no resources exist
		},
	}
}

func getUserTypeDefinition() *openfgav1.TypeDefinition {
	return &openfgav1.TypeDefinition{
		Type: "iam.miloapis.com/InternalUser",
		Metadata: &openfgav1.Metadata{
			Relations: map[string]*openfgav1.RelationMetadata{},
			SourceInfo: &openfgav1.SourceInfo{
				File: "dynamically_managed_iam_datumapis_com.fga",
			},
			Module: "iam.miloapis.com",
		},
		Relations: map[string]*openfgav1.Userset{},
	}
}

func getUserGroupTypeDefinition() *openfgav1.TypeDefinition {
	return &openfgav1.TypeDefinition{
		Type: "iam.miloapis.com/InternalUserGroup",
		Metadata: &openfgav1.Metadata{
			Relations: map[string]*openfgav1.RelationMetadata{
				"member": {
					DirectlyRelatedUserTypes: []*openfgav1.RelationReference{
						{
							Type: "iam.miloapis.com/InternalUser",
						},
					},
				},
				"assignee": {
					DirectlyRelatedUserTypes: nil,
				},
			},
			SourceInfo: &openfgav1.SourceInfo{
				File: "dynamically_managed_iam_datumapis_com.fga",
			},
			Module: "iam.miloapis.com",
		},
		Relations: map[string]*openfgav1.Userset{
			"member": {
				Userset: &openfgav1.Userset_This{
					This: &openfgav1.DirectUserset{},
				},
			},
			"assignee": {
				Userset: &openfgav1.Userset_ComputedUserset{
					ComputedUserset: &openfgav1.ObjectRelation{
						Relation: "member",
					},
				},
			},
		},
	}
}

func getRoleTypeDefinition(permissions []string) *openfgav1.TypeDefinition {
	// Sort permissions for deterministic ordering
	sortedPermissions := make([]string, len(permissions))
	copy(sortedPermissions, permissions)
	sort.Strings(sortedPermissions)

	// Create a new type definition for the base role type that will be used to
	// create custom roles. These roles will always be related to a "user" type
	// through a role binding.
	role := &openfgav1.TypeDefinition{
		// The InternalRole type will represent the application of an Role in the
		// OpenFGA backend. The standard Role type is only used to gate access to a
		// role resource.
		Type: "iam.miloapis.com/InternalRole",
		Metadata: &openfgav1.Metadata{
			Relations: map[string]*openfgav1.RelationMetadata{
				"assignee": {
					DirectlyRelatedUserTypes: []*openfgav1.RelationReference{
						{
							Type: "iam.miloapis.com/InternalUser",
						},
					},
				},
			},
			SourceInfo: &openfgav1.SourceInfo{
				File: "dynamically_managed_iam_datumapis_com.fga",
			},
			Module: "iam.miloapis.com",
		},
		Relations: map[string]*openfgav1.Userset{
			"assignee": {
				Userset: &openfgav1.Userset_This{
					This: &openfgav1.DirectUserset{},
				},
			},
		},
	}

	for _, permission := range sortedPermissions {
		hashedPermission := hashPermission(permission)

		role.Metadata.Relations[hashedPermission] = &openfgav1.RelationMetadata{
			DirectlyRelatedUserTypes: []*openfgav1.RelationReference{
				{
					Type:               "iam.miloapis.com/InternalUser",
					RelationOrWildcard: &openfgav1.RelationReference_Wildcard{},
				},
			},
		}
		role.Relations[hashedPermission] = &openfgav1.Userset{
			Userset: &openfgav1.Userset_This{
				This: &openfgav1.DirectUserset{},
			},
		}
	}

	return role
}

func getRoleBindingTypeDefinition(permissions []string) *openfgav1.TypeDefinition {
	// Sort permissions for deterministic ordering
	sortedPermissions := make([]string, len(permissions))
	copy(sortedPermissions, permissions)
	sort.Strings(sortedPermissions)

	// Create a new type definition for the base role type that will be used to
	// create custom roles. These roles will always be related to a "user" type
	// through a role binding.
	roleBinding := &openfgav1.TypeDefinition{
		Type: "iam.miloapis.com/RoleBinding",
		Metadata: &openfgav1.Metadata{
			Relations: map[string]*openfgav1.RelationMetadata{
				"iam.miloapis.com/InternalRole": {
					DirectlyRelatedUserTypes: []*openfgav1.RelationReference{
						{
							Type: "iam.miloapis.com/InternalRole",
						},
					},
				},
				"iam.miloapis.com/InternalUser": {
					DirectlyRelatedUserTypes: []*openfgav1.RelationReference{
						{
							Type: "iam.miloapis.com/InternalUser",
						},
						{
							Type:               "iam.miloapis.com/InternalUser",
							RelationOrWildcard: &openfgav1.RelationReference_Wildcard{},
						},
						// Ensure only InternalUser is allowed here if all subjects are mapped to it for this relation
						{
							Type: "iam.miloapis.com/InternalUserGroup",
							RelationOrWildcard: &openfgav1.RelationReference_Relation{
								Relation: "assignee",
							},
						},
					},
				},
			},
			SourceInfo: &openfgav1.SourceInfo{
				File: "dynamically_managed_iam_datumapis_com.fga",
			},
			Module: "iam.miloapis.com",
		},
		Relations: map[string]*openfgav1.Userset{
			"iam.miloapis.com/InternalRole": {
				Userset: &openfgav1.Userset_This{
					This: &openfgav1.DirectUserset{},
				},
			},
			"iam.miloapis.com/InternalUser": {
				Userset: &openfgav1.Userset_This{
					This: &openfgav1.DirectUserset{},
				},
			},
		},
	}

	for _, permission := range sortedPermissions {
		hashedPermission := hashPermission(permission)

		roleBinding.Relations[hashedPermission] = &openfgav1.Userset{
			Userset: &openfgav1.Userset_Intersection{
				Intersection: &openfgav1.Usersets{
					Child: []*openfgav1.Userset{
						{
							Userset: &openfgav1.Userset_ComputedUserset{
								ComputedUserset: &openfgav1.ObjectRelation{
									Relation: "iam.miloapis.com/InternalUser",
								},
							},
						},
						{
							Userset: &openfgav1.Userset_TupleToUserset{
								TupleToUserset: &openfgav1.TupleToUserset{
									ComputedUserset: &openfgav1.ObjectRelation{
										Relation: hashedPermission,
									},
									Tupleset: &openfgav1.ObjectRelation{
										Relation: "iam.miloapis.com/InternalRole",
									},
								},
							},
						},
					},
				},
			},
		}
	}

	return roleBinding
}

func getRootTypeDefinition(permissions []string, resourceTypes []string) *openfgav1.TypeDefinition {
	// Sort inputs for deterministic ordering
	sortedPermissions := make([]string, len(permissions))
	copy(sortedPermissions, permissions)
	sort.Strings(sortedPermissions)

	sortedResourceTypes := make([]string, len(resourceTypes))
	copy(sortedResourceTypes, resourceTypes)
	sort.Strings(sortedResourceTypes)

	// Build the list of relation references for all resource types
	relationReferences := make([]*openfgav1.RelationReference, 0, len(sortedResourceTypes))
	for _, resourceType := range sortedResourceTypes {
		relationReferences = append(relationReferences, &openfgav1.RelationReference{
			Type: resourceType,
		})
	}

	// This function should only be called when ProtectedResources exist,
	// so we should always have at least one resource type
	if len(relationReferences) == 0 {
		panic("getRootTypeDefinition called with no resource types - this should not happen when ProtectedResources exist")
	}

	root := &openfgav1.TypeDefinition{
		Type: "iam.miloapis.com/Root",
		Metadata: &openfgav1.Metadata{
			Relations: map[string]*openfgav1.RelationMetadata{
				"iam.miloapis.com/RoleBinding": {
					DirectlyRelatedUserTypes: []*openfgav1.RelationReference{
						{
							Type: "iam.miloapis.com/RoleBinding",
						},
					},
				},
				"iam.miloapis.com/RootBinding": {
					DirectlyRelatedUserTypes: relationReferences,
				},
			},
			SourceInfo: &openfgav1.SourceInfo{
				File: "dynamically_managed_iam_datumapis_com.fga",
			},
			Module: "iam.miloapis.com",
		},
		Relations: map[string]*openfgav1.Userset{
			"iam.miloapis.com/RoleBinding": {
				Userset: &openfgav1.Userset_This{},
			},
			"iam.miloapis.com/RootBinding": {
				Userset: &openfgav1.Userset_This{},
			},
		},
	}

	// Add all permissions to the Root type so ResourceKind bindings can grant any permission
	for _, permission := range sortedPermissions {
		hashedPermission := hashPermission(permission)
		root.Relations[hashedPermission] = &openfgav1.Userset{
			Userset: &openfgav1.Userset_TupleToUserset{
				TupleToUserset: &openfgav1.TupleToUserset{
					Tupleset: &openfgav1.ObjectRelation{
						Relation: "iam.miloapis.com/RoleBinding",
					},
					ComputedUserset: &openfgav1.ObjectRelation{
						Relation: hashedPermission,
					},
				},
			},
		}
	}

	return root
}

func hashPermission(permission string) string {
	hasher := fnv.New32a()
	//revive:disable-next-line:unhandled-error a
	hasher.Write([]byte(permission))

	return hex.EncodeToString(hasher.Sum(nil))
}

func HashPermission(permission string) string {
	return hashPermission(permission)
}

// calculateHierarchicalPermissions calculates which permissions each resource type should have
// based on its position in the hierarchy. Each resource gets its own permissions plus
// all permissions from its descendants (children, grandchildren, etc.)
func calculateHierarchicalPermissions(rootNode *resourceGraphNode) map[string][]string {
	hierarchicalPermissions := make(map[string][]string)

	// Traverse the entire graph and calculate permissions for each node
	calculatePermissionsForNode(rootNode, hierarchicalPermissions)

	return hierarchicalPermissions
}

// calculatePermissionsForNode recursively calculates permissions for a node and all its descendants
func calculatePermissionsForNode(node *resourceGraphNode, permissionsMap map[string][]string) []string {
	if node == nil {
		return []string{}
	}

	// Skip the root IAM node as it's handled separately
	if node.ResourceType == "iam.miloapis.com/Root" {
		// Process children but don't assign permissions to the IAM root
		for _, child := range node.ChildResources {
			calculatePermissionsForNode(child, permissionsMap)
		}
		return []string{}
	}

	// If we've already calculated permissions for this node, return them
	if permissions, exists := permissionsMap[node.ResourceType]; exists {
		return permissions
	}

	// Start with this node's direct permissions
	nodePermissions := make([]string, len(node.DirectPermissions))
	copy(nodePermissions, node.DirectPermissions)

	// Add permissions from all child resources
	for _, child := range node.ChildResources {
		childPermissions := calculatePermissionsForNode(child, permissionsMap)
		nodePermissions = append(nodePermissions, childPermissions...)
	}

	// Remove duplicates
	nodePermissions = removeDuplicatePermissions(nodePermissions)

	// Store the calculated permissions
	permissionsMap[node.ResourceType] = nodePermissions

	return nodePermissions
}

// removeDuplicatePermissions removes duplicate permission strings from a slice
func removeDuplicatePermissions(permissions []string) []string {
	seen := make(map[string]bool)
	result := []string{}

	for _, permission := range permissions {
		if !seen[permission] {
			seen[permission] = true
			result = append(result, permission)
		}
	}

	return result
}

// getResourceTypeDefinitionsWithHierarchicalPermissions creates type definitions with
// permissions assigned based on hierarchical relationships
func getResourceTypeDefinitionsWithHierarchicalPermissions(hierarchicalPermissions map[string][]string, node *resourceGraphNode) map[string]*openfgav1.TypeDefinition {
	types := map[string]*openfgav1.TypeDefinition{}

	// Process the current node
	if node.ResourceType != "iam.miloapis.com/Root" {
		permissions := hierarchicalPermissions[node.ResourceType]
		if permissions == nil {
			permissions = []string{} // Default to empty if not found
		}
		types[node.ResourceType] = getResourceTypeDefinition(permissions, node)
	}

	// Process all child nodes
	for _, child := range node.ChildResources {
		childTypes := getResourceTypeDefinitionsWithHierarchicalPermissions(hierarchicalPermissions, child)
		for k, v := range childTypes {
			types[k] = v
		}
	}

	return types
}
