package openfga

import (
	"context"
	"encoding/hex"
	"fmt"
	"hash/fnv"
	"maps"
	"strings"

	openfgav1 "github.com/openfga/api/proto/openfga/v1"
	iamdatumapiscomv1alpha1 "go.miloapis.com/milo/pkg/apis/iam/v1alpha1"
	"google.golang.org/protobuf/types/known/wrapperspb"
)

type AuthorizationModelReconciler struct {
	StoreID string
	OpenFGA openfgav1.OpenFGAServiceClient
}

func (r *AuthorizationModelReconciler) ReconcileAuthorizationModel(ctx context.Context, protectedResources []iamdatumapiscomv1alpha1.ProtectedResource) error {
	currentAuthorizationModel, err := r.getCurrentAuthorizationModel(ctx)
	if err != nil {
		return fmt.Errorf("failed to get current authorization model: %w", err)
	}

	newAuthorizationModel, err := r.createExpectedAuthorizationModel(protectedResources)
	if err != nil {
		return fmt.Errorf("failed to create new authorization model: %w", err)
	}

	mergedAuthorizationModel := &openfgav1.AuthorizationModel{
		SchemaVersion: newAuthorizationModel.SchemaVersion,
		// Conditions are not dynamically generated by the IAM system so we can
		// safely set the conditions to whatever is already in the authorization
		// model.
		//
		// TODO: Update when conditions are dynamically created by the IAM system.
		Conditions: currentAuthorizationModel.Conditions,
	}

	// Go through the existing type definitions and add any that were provided
	// through the OpenFGA schema language.
	for _, typeDefinition := range currentAuthorizationModel.TypeDefinitions {
		// The type definitions added by the IAM system will always be in the
		// format `{service_name}/{resource_type}`. Since this format is only
		// valid when building the resource model in JSON, we can safely
		// guarantee that type definitions added by Datum OS through the OpenFGA
		// schema language will never contain a "/" character.
		if len(strings.Split(typeDefinition.Type, "/")) == 1 {
			mergedAuthorizationModel.TypeDefinitions = append(mergedAuthorizationModel.TypeDefinitions, typeDefinition)
		}
	}

	mergedAuthorizationModel.TypeDefinitions = append(mergedAuthorizationModel.TypeDefinitions, newAuthorizationModel.TypeDefinitions...)

	_, err = r.OpenFGA.WriteAuthorizationModel(ctx, &openfgav1.WriteAuthorizationModelRequest{
		StoreId:         r.StoreID,
		SchemaVersion:   mergedAuthorizationModel.SchemaVersion,
		TypeDefinitions: mergedAuthorizationModel.TypeDefinitions,
		Conditions:      mergedAuthorizationModel.Conditions,
	})
	if err != nil {
		return fmt.Errorf("failed to reconcile authorization model: %w", err)
	}

	return nil
}

func (r *AuthorizationModelReconciler) getCurrentAuthorizationModel(ctx context.Context) (*openfgav1.AuthorizationModel, error) {
	models, err := r.OpenFGA.ReadAuthorizationModels(ctx, &openfgav1.ReadAuthorizationModelsRequest{
		StoreId: r.StoreID,
		// Only request the first result because it'll always be the latest
		// authorization model that was created for the store.
		PageSize: wrapperspb.Int32(1),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to list authorization models: %w", err)
	}

	if len(models.AuthorizationModels) == 0 {
		// No authorization model has been created yet so we'll just return an
		// empty model.
		return &openfgav1.AuthorizationModel{}, nil
	}

	// Retrieve the full authorization model definition
	resp, err := r.OpenFGA.ReadAuthorizationModel(ctx, &openfgav1.ReadAuthorizationModelRequest{
		StoreId: r.StoreID,
		Id:      models.AuthorizationModels[0].Id,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get authorization model: %w", err)
	}

	return resp.AuthorizationModel, nil
}

func (r *AuthorizationModelReconciler) createExpectedAuthorizationModel(protectedResources []iamdatumapiscomv1alpha1.ProtectedResource) (*openfgav1.AuthorizationModel, error) {
	permissions := getAllPermissions(protectedResources)

	resourceGraph, err := getResourceGraph(protectedResources)
	if err != nil {
		return nil, fmt.Errorf("failed to get resource graph: %v", err)
	}

	typeDefinitions := []*openfgav1.TypeDefinition{
		getUserTypeDefinition(),
		getUserGroupTypeDefinition(),
		getRoleTypeDefinition(permissions),
		getRoleBindingTypeDefinition(permissions),
	}

	// TODO: We may be able to optimize which permissions are assigned to each
	//       resource. All permissions are attached to all resources just to make
	//       it easy and not have to add validation for making sure a permission
	//       is available on a resource.
	for _, typeDefinition := range getResourceTypeDefinitions(permissions, resourceGraph) {
		typeDefinitions = append(typeDefinitions, typeDefinition)
	}

	return &openfgav1.AuthorizationModel{
		SchemaVersion:   "1.2",
		TypeDefinitions: typeDefinitions,
	}, nil
}

func getResourceParentRelatedTypes(parents []string) (relations []*openfgav1.RelationReference) {
	for _, parent := range parents {
		relations = append(relations, &openfgav1.RelationReference{
			Type: parent,
		})
	}
	return
}

func getResourceTypeDefinitions(permissions []string, node *resourceGraphNode) map[string]*openfgav1.TypeDefinition {
	types := map[string]*openfgav1.TypeDefinition{}
	types[node.ResourceType] = getResourceTypeDefinition(permissions, node)
	for _, child := range node.ChildResources {
		maps.Copy(types, getResourceTypeDefinitions(permissions, child))
	}
	return types
}

func getResourceTypeDefinition(permissions []string, resourceNode *resourceGraphNode) *openfgav1.TypeDefinition {
	typeDefinition := &openfgav1.TypeDefinition{
		Type: resourceNode.ResourceType,
		Metadata: &openfgav1.Metadata{
			Relations: map[string]*openfgav1.RelationMetadata{
				// All resources can have a role binding associated with it to
				// grant a subject access directly to the Resource. Permissions
				// bound to the resource will be inherited by any child
				// resources.
				"iam.miloapis.com/RoleBinding": {
					DirectlyRelatedUserTypes: []*openfgav1.RelationReference{
						{
							Type: "iam.miloapis.com/RoleBinding",
						},
					},
				},
			},
			SourceInfo: &openfgav1.SourceInfo{
				File: "dynamically_managed_iam_datumapis_com.fga",
			},
			Module: strings.Split(resourceNode.ResourceType, "/")[0],
		},
		Relations: map[string]*openfgav1.Userset{
			"iam.miloapis.com/RoleBinding": {
				Userset: &openfgav1.Userset_This{},
			},
		},
	}

	// Only create a parent reference if the resource has parent relationships and
	// we're not working on the root resource.
	if len(resourceNode.ParentResources) > 0 {
		typeDefinition.Metadata.Relations["parent"] = &openfgav1.RelationMetadata{
			DirectlyRelatedUserTypes: getResourceParentRelatedTypes(resourceNode.ParentResources),
		}
		typeDefinition.Relations["parent"] = &openfgav1.Userset{
			Userset: &openfgav1.Userset_This{},
		}
	}

	for _, permission := range permissions {
		hashedPermission := hashPermission(permission)

		typeDefinition.Relations[hashedPermission] = &openfgav1.Userset{
			Userset: &openfgav1.Userset_Union{
				Union: &openfgav1.Usersets{
					Child: []*openfgav1.Userset{
						{
							Userset: &openfgav1.Userset_TupleToUserset{
								TupleToUserset: &openfgav1.TupleToUserset{
									Tupleset: &openfgav1.ObjectRelation{
										Relation: "iam.miloapis.com/RoleBinding",
									},
									ComputedUserset: &openfgav1.ObjectRelation{
										Relation: hashedPermission,
									},
								},
							},
						},
					},
				},
			},
		}

		if len(resourceNode.ParentResources) > 0 {
			typeDefinition.Relations[hashedPermission].GetUnion().Child = append(typeDefinition.Relations[hashedPermission].GetUnion().Child,
				&openfgav1.Userset{
					Userset: &openfgav1.Userset_TupleToUserset{
						TupleToUserset: &openfgav1.TupleToUserset{
							Tupleset: &openfgav1.ObjectRelation{
								Relation: "parent",
							},
							ComputedUserset: &openfgav1.ObjectRelation{
								Relation: hashedPermission,
							},
						},
					},
				},
			)
		}
	}

	return typeDefinition
}

func getAllPermissions(protectedResources []iamdatumapiscomv1alpha1.ProtectedResource) []string {
	var permissions []string
	for _, pr := range protectedResources {
		if pr.Spec.ServiceRef.Name == "" {
			fmt.Printf("Warning: ProtectedResource %s has empty ServiceRef.Name, skipping its permissions\n", pr.Name)
			continue
		}
		for _, permission := range pr.Spec.Permissions {
			if pr.Spec.Plural == "" {
				fmt.Printf("Warning: ProtectedResource %s (service %s) has an empty Plural name, skipping permission '%s'\n", pr.Name, pr.Spec.ServiceRef.Name, permission)
				continue
			}
			permissions = append(permissions, fmt.Sprintf("%s/%s.%s", pr.Spec.ServiceRef.Name, pr.Spec.Plural, permission))
		}
	}
	return permissions
}

func getUserTypeDefinition() *openfgav1.TypeDefinition {
	return &openfgav1.TypeDefinition{
		Type: "iam.miloapis.com/InternalUser",
		Metadata: &openfgav1.Metadata{
			Relations: map[string]*openfgav1.RelationMetadata{},
			SourceInfo: &openfgav1.SourceInfo{
				File: "dynamically_managed_iam_datumapis_com.fga",
			},
			Module: "iam.miloapis.com",
		},
		Relations: map[string]*openfgav1.Userset{},
	}
}

func getUserGroupTypeDefinition() *openfgav1.TypeDefinition {
	return &openfgav1.TypeDefinition{
		Type: "iam.miloapis.com/InternalUserGroup",
		Metadata: &openfgav1.Metadata{
			Relations: map[string]*openfgav1.RelationMetadata{
				"member": {
					DirectlyRelatedUserTypes: []*openfgav1.RelationReference{
						{
							Type: "iam.miloapis.com/InternalUser",
						},
					},
				},
				"assignee": {
					DirectlyRelatedUserTypes: nil,
				},
			},
			SourceInfo: &openfgav1.SourceInfo{
				File: "dynamically_managed_iam_datumapis_com.fga",
			},
			Module: "iam.miloapis.com",
		},
		Relations: map[string]*openfgav1.Userset{
			"member": {
				Userset: &openfgav1.Userset_This{
					This: &openfgav1.DirectUserset{},
				},
			},
			"assignee": {
				Userset: &openfgav1.Userset_ComputedUserset{
					ComputedUserset: &openfgav1.ObjectRelation{
						Relation: "member",
					},
				},
			},
		},
	}
}

func getRoleTypeDefinition(permissions []string) *openfgav1.TypeDefinition {
	// Create a new type definition for the base role type that will be used to
	// create custom roles. These roles will always be related to a "user" type
	// through a role binding.
	role := &openfgav1.TypeDefinition{
		// The InternalRole type will represent the application of an Role in the
		// OpenFGA backend. The standard Role type is only used to gate access to a
		// role resource.
		Type: "iam.miloapis.com/InternalRole",
		Metadata: &openfgav1.Metadata{
			Relations: map[string]*openfgav1.RelationMetadata{
				"assignee": {
					DirectlyRelatedUserTypes: []*openfgav1.RelationReference{
						{
							Type: "iam.miloapis.com/InternalUser",
						},
					},
				},
			},
			SourceInfo: &openfgav1.SourceInfo{
				File: "dynamically_managed_iam_datumapis_com.fga",
			},
			Module: "iam.miloapis.com",
		},
		Relations: map[string]*openfgav1.Userset{
			"assignee": {
				Userset: &openfgav1.Userset_This{
					This: &openfgav1.DirectUserset{},
				},
			},
		},
	}

	for _, permission := range permissions {
		hashedPermission := hashPermission(permission)

		role.Metadata.Relations[hashedPermission] = &openfgav1.RelationMetadata{
			DirectlyRelatedUserTypes: []*openfgav1.RelationReference{
				{
					Type:               "iam.miloapis.com/InternalUser",
					RelationOrWildcard: &openfgav1.RelationReference_Wildcard{},
				},
			},
		}
		role.Relations[hashedPermission] = &openfgav1.Userset{
			Userset: &openfgav1.Userset_This{
				This: &openfgav1.DirectUserset{},
			},
		}
	}

	return role
}

func getRoleBindingTypeDefinition(permissions []string) *openfgav1.TypeDefinition {
	// Create a new type definition for the base role type that will be used to
	// create custom roles. These roles will always be related to a "user" type
	// through a role binding.
	roleBinding := &openfgav1.TypeDefinition{
		Type: "iam.miloapis.com/RoleBinding",
		Metadata: &openfgav1.Metadata{
			Relations: map[string]*openfgav1.RelationMetadata{
				"iam.miloapis.com/InternalRole": {
					DirectlyRelatedUserTypes: []*openfgav1.RelationReference{
						{
							Type: "iam.miloapis.com/InternalRole",
						},
					},
				},
				"iam.miloapis.com/InternalUser": {
					DirectlyRelatedUserTypes: []*openfgav1.RelationReference{
						{
							Type: "iam.miloapis.com/InternalUser",
						},
						{
							Type:               "iam.miloapis.com/InternalUser",
							RelationOrWildcard: &openfgav1.RelationReference_Wildcard{},
						},
						// Ensure only InternalUser is allowed here if all subjects are mapped to it for this relation
						{
							Type: "iam.miloapis.com/InternalUserGroup",
							RelationOrWildcard: &openfgav1.RelationReference_Relation{
								Relation: "assignee",
							},
						},
					},
				},
			},
			SourceInfo: &openfgav1.SourceInfo{
				File: "dynamically_managed_iam_datumapis_com.fga",
			},
			Module: "iam.miloapis.com",
		},
		Relations: map[string]*openfgav1.Userset{
			"iam.miloapis.com/InternalRole": {
				Userset: &openfgav1.Userset_This{
					This: &openfgav1.DirectUserset{},
				},
			},
			"iam.miloapis.com/InternalUser": {
				Userset: &openfgav1.Userset_This{
					This: &openfgav1.DirectUserset{},
				},
			},
		},
	}

	for _, permission := range permissions {
		hashedPermission := hashPermission(permission)

		roleBinding.Relations[hashedPermission] = &openfgav1.Userset{
			Userset: &openfgav1.Userset_Intersection{
				Intersection: &openfgav1.Usersets{
					Child: []*openfgav1.Userset{
						{
							Userset: &openfgav1.Userset_ComputedUserset{
								ComputedUserset: &openfgav1.ObjectRelation{
									Relation: "iam.miloapis.com/InternalUser",
								},
							},
						},
						{
							Userset: &openfgav1.Userset_TupleToUserset{
								TupleToUserset: &openfgav1.TupleToUserset{
									ComputedUserset: &openfgav1.ObjectRelation{
										Relation: hashedPermission,
									},
									Tupleset: &openfgav1.ObjectRelation{
										Relation: "iam.miloapis.com/InternalRole",
									},
								},
							},
						},
					},
				},
			},
		}
	}

	return roleBinding
}

func hashPermission(permission string) string {
	hasher := fnv.New32a()
	hasher.Write([]byte(permission))

	return hex.EncodeToString(hasher.Sum(nil))
}

func HashPermission(permission string) string {
	return hashPermission(permission)
}
